/**
 * Multi-Account Google Services Manager
 * Handles switching between multiple Google accounts
 * Supports both Service Accounts (JWT) and OAuth2 User Accounts
 * 
 * Usage:
 *   const manager = new MultiAccountManager();
 *   await manager.initialize();
 *   manager.switchTo('GorahaBot');
 *   const auth = manager.getActive();
 */

import { readFileSync, existsSync } from 'fs';
import { join } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { google } from 'googleapis';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIGURATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const ACCOUNTS_REGISTRY_PATH = join(__dirname, 'accounts.json');
const DEFAULT_SCOPES = [
  'https://www.googleapis.com/auth/spreadsheets',
  'https://www.googleapis.com/auth/drive',
  'https://www.googleapis.com/auth/contacts'
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MULTI-ACCOUNT MANAGER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MultiAccountManager {
  constructor() {
    this.accountsRegistry = null;
    this.authCache = {};        // Cache for loaded auth objects
    this.activeAccount = null;
    this.isInitialized = false;
    this.scopeDefaults = DEFAULT_SCOPES;

    console.log('ğŸ“‹ MultiAccountManager initialized');
  }

  /**
   * Initialize the manager - load accounts registry and set default account
   */
  async initialize() {
    try {
      if (!existsSync(ACCOUNTS_REGISTRY_PATH)) {
        throw new Error(`Accounts registry not found: ${ACCOUNTS_REGISTRY_PATH}`);
      }

      // Load accounts registry
      const registryContent = readFileSync(ACCOUNTS_REGISTRY_PATH, 'utf8');
      this.accountsRegistry = JSON.parse(registryContent);
      
      console.log(`âœ… Accounts registry loaded (${this.listAccounts().length} accounts)`);

      // Set default account
      const defaultAccountName = this.accountsRegistry.default || 'PowerAgent';
      await this.switchTo(defaultAccountName);
      
      this.isInitialized = true;
      console.log(`âœ… MultiAccountManager ready. Default: ${this.activeAccount}`);

      return true;
    } catch (error) {
      console.error('âŒ Failed to initialize MultiAccountManager:', error.message);
      this.isInitialized = false;
      return false;
    }
  }

  /**
   * Switch to a different account
   * @param {string} accountName - Account name from registry (e.g., 'PowerAgent', 'GorahaBot')
   * @returns {Promise<boolean>} Success status
   */
  async switchTo(accountName) {
    try {
      if (!this.accountsRegistry) {
        throw new Error('Not initialized. Call initialize() first');
      }

      const account = this.accountsRegistry.accounts[accountName];
      if (!account) {
        throw new Error(`Account not found: ${accountName}`);
      }

      if (account.status !== 'active') {
        throw new Error(`Account not active: ${accountName} (status: ${account.status})`);
      }

      console.log(`ğŸ”„ Switching to account: ${accountName} (${account.name})`);

      // Check if auth already cached
      if (this.authCache[accountName]) {
        console.log(`âœ… Using cached auth for ${accountName}`);
        this.activeAccount = accountName;
        return true;
      }

      // Load auth based on account type
      let auth;

      if (account.type === 'service_account') {
        auth = await this._loadServiceAccountAuth(accountName, account);
      } else if (account.type === 'oauth2_user') {
        auth = await this._loadOAuth2Auth(accountName, account);
      } else {
        throw new Error(`Unknown account type: ${account.type}`);
      }

      if (!auth) {
        throw new Error(`Failed to load auth for ${accountName}`);
      }

      // Cache the auth
      this.authCache[accountName] = auth;
      this.activeAccount = accountName;

      // Update last used timestamp
      account.lastUsed = new Date().toISOString();

      console.log(`âœ… Switched to ${accountName}`);
      return true;

    } catch (error) {
      console.error(`âŒ Failed to switch to ${accountName}:`, error.message);
      return false;
    }
  }

  /**
   * Load Service Account authentication (JWT)
   * @private
   */
  async _loadServiceAccountAuth(accountName, account) {
    try {
      const keysPath = join(__dirname, account.keysFile);
      
      if (!existsSync(keysPath)) {
        throw new Error(`Keys file not found: ${keysPath}`);
      }

      const keys = JSON.parse(readFileSync(keysPath, 'utf8'));

      const auth = new google.auth.GoogleAuth({
        credentials: {
          type: keys.type,
          project_id: keys.project_id,
          private_key_id: keys.private_key_id,
          private_key: keys.private_key,
          client_email: keys.client_email,
          client_id: keys.client_id,
          auth_uri: keys.auth_uri,
          token_uri: keys.token_uri,
          auth_provider_x509_cert_url: keys.auth_provider_x509_cert_url,
          client_x509_cert_url: keys.client_x509_cert_url,
        },
        scopes: account.scopes || this.scopeDefaults
      });

      // Verify auth works
      await auth.getAccessToken();
      console.log(`   âœ“ Service Account Auth loaded: ${account.name}`);

      return auth;
    } catch (error) {
      console.error(`   âœ— Service Account Auth Error:`, error.message);
      throw error;
    }
  }

  /**
   * Load OAuth2 User authentication
   * @private
   */
  async _loadOAuth2Auth(accountName, account) {
    try {
      const tokenPath = join(__dirname, '..', '..', account.tokenFile);

      if (!existsSync(tokenPath)) {
        console.warn(`   âš ï¸  OAuth2 token not found: ${tokenPath}`);
        console.log(`   â„¹ï¸  Run setup-oauth.js to authorize this account`);
        return null;
      }

      const credentials = JSON.parse(readFileSync(tokenPath, 'utf8'));

      const oauth2Client = new google.auth.OAuth2(
        credentials.client_id,
        credentials.client_secret,
        credentials.redirect_uris[0]
      );

      oauth2Client.setCredentials({
        access_token: credentials.access_token,
        refresh_token: credentials.refresh_token,
        expiry_date: credentials.expiry_date
      });

      console.log(`   âœ“ OAuth2 Auth loaded: ${account.name}`);

      return oauth2Client;
    } catch (error) {
      console.error(`   âœ— OAuth2 Auth Error:`, error.message);
      throw error;
    }
  }

  /**
   * Get the active account's auth object
   * @returns {Object} Auth object (GoogleAuth or OAuth2Client)
   */
  getActive() {
    if (!this.activeAccount) {
      throw new Error('No active account. Call switchTo() first');
    }

    const auth = this.authCache[this.activeAccount];
    if (!auth) {
      throw new Error(`No cached auth for ${this.activeAccount}`);
    }

    return auth;
  }

  /**
   * Get active account information
   * @returns {Object} Account metadata
   */
  getActiveAccountInfo() {
    if (!this.activeAccount || !this.accountsRegistry) {
      return null;
    }

    return {
      id: this.activeAccount,
      ...this.accountsRegistry.accounts[this.activeAccount]
    };
  }

  /**
   * List all available accounts
   * @returns {Array} Account names
   */
  listAccounts() {
    if (!this.accountsRegistry) {
      return [];
    }

    return Object.keys(this.accountsRegistry.accounts);
  }

  /**
   * Get account by name
   * @param {string} accountName
   * @returns {Object} Account metadata
   */
  getAccountByName(accountName) {
    if (!this.accountsRegistry) {
      return null;
    }

    return this.accountsRegistry.accounts[accountName] || null;
  }

  /**
   * Check if account exists and is active
   * @param {string} accountName
   * @returns {boolean}
   */
  isAccountActive(accountName) {
    const account = this.getAccountByName(accountName);
    return account && account.status === 'active';
  }

  /**
   * Get all active accounts
   * @returns {Array} List of active account names
   */
  getActiveAccounts() {
    return this.listAccounts().filter(name => this.isAccountActive(name));
  }

  /**
   * Get auth for specific account (without switching)
   * @param {string} accountName
   * @returns {Promise<Object>} Auth object
   */
  async getAuthForAccount(accountName) {
    try {
      const account = this.getAccountByName(accountName);
      if (!account) {
        throw new Error(`Account not found: ${accountName}`);
      }

      // Check cache first
      if (this.authCache[accountName]) {
        return this.authCache[accountName];
      }

      // Load based on type
      let auth;
      if (account.type === 'service_account') {
        auth = await this._loadServiceAccountAuth(accountName, account);
      } else if (account.type === 'oauth2_user') {
        auth = await this._loadOAuth2Auth(accountName, account);
      }

      if (auth) {
        this.authCache[accountName] = auth;
      }

      return auth;
    } catch (error) {
      console.error(`âŒ Failed to get auth for ${accountName}:`, error.message);
      return null;
    }
  }

  /**
   * Perform operation with specific account (without switching)
   * @param {string} accountName
   * @param {Function} operation - Async function receiving auth as parameter
   * @returns {Promise<Object>} Operation result
   */
  async withAccount(accountName, operation) {
    try {
      const auth = await this.getAuthForAccount(accountName);
      if (!auth) {
        throw new Error(`Could not get auth for ${accountName}`);
      }

      return await operation(auth);
    } catch (error) {
      console.error(`âŒ Operation failed for ${accountName}:`, error.message);
      throw error;
    }
  }

  /**
   * Get registry data
   * @returns {Object} Full accounts registry
   */
  getRegistry() {
    return this.accountsRegistry;
  }

  /**
   * Summary of current status
   */
  status() {
    console.log('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.log('â•‘  MultiAccountManager Status                â•‘');
    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

    if (!this.isInitialized) {
      console.log('âŒ Not initialized');
      return;
    }

    console.log(`âœ… Initialized: Yes`);
    console.log(`ğŸ“ Active Account: ${this.activeAccount}`);
    console.log(`\nğŸ“Š Registered Accounts:`);

    this.listAccounts().forEach(name => {
      const account = this.getAccountByName(name);
      const status = account.status === 'active' ? 'âœ…' : 'âš ï¸ ';
      const type = account.type === 'service_account' ? 'ğŸ”‘' : 'ğŸ‘¤';
      console.log(`   ${status} ${type} ${name} (${account.name})`);
    });

    console.log(`\nğŸ“¦ Cached Auths: ${Object.keys(this.authCache || {}).length}`);
    console.log('');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SINGLETON INSTANCE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let instance = null;

export async function getMultiAccountManager() {
  if (!instance) {
    instance = new MultiAccountManager();
    await instance.initialize();
  }
  return instance;
}

export function getManagerSync() {
  if (!instance) {
    throw new Error('MultiAccountManager not initialized. Call getMultiAccountManager() first');
  }
  return instance;
}

export default MultiAccountManager;
